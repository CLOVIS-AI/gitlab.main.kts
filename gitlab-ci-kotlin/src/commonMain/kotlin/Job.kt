/*
 * Copyright (c) 2022-2025, OpenSavvy and contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package opensavvy.gitlab.ci

import opensavvy.gitlab.ci.script.Command
import opensavvy.gitlab.ci.script.CommandDsl
import opensavvy.gitlab.ci.utils.generateReadOnlyDelegateProvider
import opensavvy.gitlab.ci.yaml.Yaml
import opensavvy.gitlab.ci.yaml.yaml
import opensavvy.gitlab.ci.yaml.yamlList
import opensavvy.gitlab.ci.yaml.yamlMap

/**
 * A single execution step in a [pipeline][GitLabCi].
 *
 * Read more in the [GitLab documentation](https://docs.gitlab.com/ee/ci/jobs/).
 */
class Job internal constructor(
	val name: String,
	val stage: Stage? = null,
) : YamlExport {

	//region Image & services

	var image: ContainerImage? = null
		private set(value) {
			if (field != null && field != value)
				System.err.println("Job '$name': setting the image to $value overrides previous setting $field")
			field = value
		}

	/**
	 * The container image used to execute this job.
	 *
	 * Example:
	 * ```kotlin
	 * val ubuntu by job {
	 *     image("ubuntu")
	 * }
	 * ```
	 *
	 * Read more in the [GitLab documentation](https://docs.gitlab.com/ee/ci/yaml/#image).
	 */
	fun image(name: String, version: String = "latest", configuration: ContainerImage.() -> Unit = {}) {
		image = ContainerImage("$name:$version").apply(configuration)
	}

	val services = HashSet<ContainerService>()

	/**
	 * Additional container images used by this job.
	 *
	 * Example:
	 * ```kotlin
	 * val docker by job {
	 *     image("docker")
	 *     service("docker", version = "dind")
	 * }
	 * ```
	 *
	 * Read more in the [GitLab documentation](https://docs.gitlab.com/ee/ci/yaml/#services).
	 */
	fun service(name: String, version: String = "latest", configuration: ContainerService.() -> Unit = {}) {
		services += ContainerService("$name:$version").apply(configuration)
	}

	//endregion
	//region Script

	val script = ArrayList<Command>()

	/**
	 * Adds commands to execute in this job.
	 *
	 * Example:
	 * ```kotlin
	 * val test by job {
	 *     script {
	 *         shell("echo Hello World")
	 *     }
	 *
	 *     script {
	 *         shell("echo You can call 'script' multiple times")
	 *         shell("echo or add multiple commands inside a single 'script' call")
	 *     }
	 * }
	 * ```
	 *
	 * Calling `script` multiple times executes the commands after the previous ones (the execution happens in the same order as in the source code).
	 *
	 * See [CommandDsl] to see what functions are available in `script`.
	 * Read more in the [GitLab documentation](https://docs.gitlab.com/ee/ci/yaml/#script).
	 */
	fun script(block: CommandDsl.() -> Unit) {
		CommandDsl(script).block()
	}

	val beforeScript = ArrayList<Command>()

	/**
	 * Adds commands to execute before the main script of this job.
	 *
	 * `beforeScript` has the same behavior as [script].
	 *
	 * Read more about the differences between [script] and `beforeScript` in the [GitLab documentation](https://docs.gitlab.com/ee/ci/yaml/#before_script).
	 */
	fun beforeScript(block: CommandDsl.() -> Unit) {
		CommandDsl(beforeScript).block()
	}

	val afterScript = ArrayList<Command>()

	/**
	 * Adds commands to execute after the main script of this job.
	 *
	 * `afterScript` has the same behavior as [script].
	 *
	 * Read more about the differences between [script] and `afterScript` in the [GitLab documentation](https://docs.gitlab.com/ee/ci/yaml/#after_script).
	 */
	fun afterScript(block: CommandDsl.() -> Unit) {
		CommandDsl(afterScript).block()
	}

	//endregion
	//region Tags

	val tags = HashSet<String>()

	/**
	 * Adds a tag to this job.
	 *
	 * Only runners that are possess the same tag(s) will be able to execute this job.
	 * For example, to run a job only on runners that run on ArchLinux and have Docker:
	 * ```kotlin
	 * val test by job {
	 *    tag("archlinux")
	 *    tag("docker")
	 *
	 *    script { â€¦ }
	 * }
	 * ```
	 * The tags themselves do not have any special meaning.
	 *
	 * Read more in the [GitLab documentation](https://docs.gitlab.com/ee/ci/yaml/#tags).
	 */
	fun tag(name: String) {
		tags += name
	}

	//endregion
	//region Dependencies

	val needs = ArrayList<Depends>()

	/**
	 * This job will wait until [job] has terminated.
	 *
	 * By default, jobs start immediately.
	 *
	 * If [artifacts] is `true`, the artifacts generated by [job] will be downloaded by the current job.
	 * If [optional] is `true`, this job will run even if [job] was excluded from this pipeline (using `rules`, `only` or `when`).
	 */
	fun dependsOn(job: Job, artifacts: Boolean = false, optional: Boolean = false) {
		needs += Depends(job, artifacts, optional)
	}

	//endregion
	//region Variables

	val variables = HashMap<String, String>()

	fun variable(name: String, value: String) {
		variables[name] = value
	}

	//endregion
	//region Cache & artifacts

	val cache = Cache()

	fun cache(configuration: Cache.() -> Unit) {
		cache.apply(configuration)
	}

	val artifacts = Artifacts()

	fun artifacts(configuration: Artifacts.() -> Unit) {
		artifacts.apply(configuration)
	}

	//endregion

	override fun toYaml(): Yaml {
		val elements = HashMap<Yaml, Yaml>()

		if (image != null)
			elements[yaml("image")] = yaml(image!!)

		if (services.isNotEmpty())
			elements[yaml("services")] = yamlList(services)

		if (stage != null)
			elements[yaml("stage")] = yaml(stage.name)

		if (script.isNotEmpty())
			elements[yaml("script")] = yamlList(script)

		if (beforeScript.isNotEmpty())
			elements[yaml("before_script")] = yamlList(beforeScript)

		if (afterScript.isNotEmpty())
			elements[yaml("after_script")] = yamlList(afterScript)

		if (tags.isNotEmpty())
			elements[yaml("tags")] = yamlList(tags.map { yaml(it) })

		elements[yaml("needs")] = yamlList(needs)

		if (variables.isNotEmpty())
			elements[yaml("variables")] = yamlMap(variables)

		elements[yaml("cache")] = yaml(cache)

		elements[yaml("artifacts")] = yaml(artifacts)

		return yamlMap(elements)
	}
}

fun GitLabCi.job(name: String, stage: Stage? = null, block: Job.() -> Unit) = Job(name, stage)
	.apply(block)
	.also { jobs += it }

fun GitLabCi.job(name: String? = null, stage: Stage? = null, block: Job.() -> Unit = {}) =
	generateReadOnlyDelegateProvider { parent, property ->
		parent.job(name ?: property.name, stage, block)
	}
